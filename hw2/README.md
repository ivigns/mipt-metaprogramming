# Многокатегорийная абстрактная фабрика

### Использование

```c++
class A {};
class B {};
class C : public A {};
class D : public B {};

using MyFactoryGetter = FactoryGetter<TypeList<TypeList<A, B>, TypeList<C, D>>>;
MyFactoryGetter factoryGetter;
```

- `FactoryGetter` - класс принимает в качестве шаблонного параметра тайплист с тайплистами продуктов, которые будут создаваться. В примере можно будет создать две разные фабрики, одна из которых будет создавать `A` и `B`, а другая - `C` и `D`. Обязательно должен быть тайплист, содержащий классы, которые являются базовыми для всех остальных продуктов. Назовем их *основными*. Также подразумевается, что у всех переданных классов есть конструктор по умолчанию.

```c++
std::shared_ptr<MyFactoryGetter::AbstractFactory> factory = factoryGetter.GetFactory<C>();
```

- `MyFactoryGetter::AbstractFactory` - тип абстрактной фабрики для созданного генератора.
- `factoryGetter.GetFactory` - в качестве шаблонного параметра передается один из продуктов, который будет генерироваться. Функция вернет указатель на фабрику, которая способна создавать все продукты из тайплиста, содержащего указанный продукт.

```c++
std::shared_ptr<B> product = factory->Get<B>();
```

- `factory->Get` - в качестве шаблонного параметра передается один из основных классов. Функция вернет указатель на объект, который умеет создавать и которй наследуется от указанного основного класса.
